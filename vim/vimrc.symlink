set nocompatible

" Load all plugins
execute pathogen#infect()
execute pathogen#helptags()

" Linux
"set guifont=Bitstream\ Vera\ Sans\ Mono\ 12

syntax enable

if has('gui_running')
  " set the screen width and height
  "set guifont=Andale_Mono:h18
  set guifont=Menlo:h14

  set background=dark
  colorscheme solarized
else
  "set background=light
  "colorscheme SolarizedDark_modified
  colorscheme twilight256
endif
"set background=dark

"let g:solarized_contrast   = "high"
"let g:solarized_visibility = "high"
"let g:solarized_bold       = 0

set antialias
set wrap
set ruler
set shiftwidth=2
"set foldmethod=indent

" use the system clipboard as the default register
" for all yank/cut/put operations
set clipboard=unnamed

"Press F2 to paste in text without indenting
set pastetoggle=<F2>

"mouse support in terminal vim
set mouse=a
set ttyfast
set ttymouse=xterm2

set expandtab

" Make splits open in sensible directions
set splitbelow
set splitright

" Stop Netrw from doing weird shit on double-click. Instead,
" double-click to select a word, triple-click to select a line
map <2-LeftMouse> bve
map <3-LeftMouse> 0V

" Show git branch in the status line
set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P

let mapleader = ","

" copy to ~/.vimbuffer
vmap <Leader>cy :w! ~/.vimbuffer<CR>
nmap <Leader>cy :.w! ~/vimbuffer<CR>
" cut to ~/.vimbuffer
vmap <Leader>cx :w! ~/.vimbuffer<CR>gvx
" paste from ~/.vimbuffer
map <Leader>cp :r ~/.vimbuffer<CR>

"Abbreviations
imap  ->
imap  =>
imap  #{
imap  <%=  %><ESC>hhi
imap  $this->

" Tab navigation (cmd-shift-[/cmd-shift-] to go to prev/next tab)
" THIS DOESN'T WORK IN TERMINAL VIM
" nmap <D-S-]> :tabn<CR>
" nmap <D-S-[> :tabp<CR>
" " cmd-N to go to tab N
" map <D-1> 1gt
" map <D-2> 2gt
" map <D-3> 3gt
" map <D-4> 4gt
" map <D-5> 5gt
" map <D-6> 6gt
" map <D-7> 7gt
" map <D-8> 8gt
" map <D-9> 9gt
" map <D-0> :tablast<CR>

" open method definition in a new tab
nnoremap <silent><Leader><C-]> <C-w><C-]><C-w>T

"Text bubbling (requires 'unimpaired' plugin)
" Bubble single lines
nmap <C-k> [e
nmap <C-j> ]e
" Bubble multiple lines
vmap <C-k> [egv
vmap <C-j> ]egv

" preserve visual selection when indenting/outdenting
vmap > >gv
vmap < <gv

"Save
map <Leader>w :w<CR>

"NERDTree
map <Leader>nt :NERDTreeToggle<CR>
map <Leader>nf :NERDTreeFind<CR>

"Ignore some files
let NERDTreeIgnore=['\.class$']
set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.class

"Taglist
map <Leader>tt :TlistToggle<CR>

"Goto file in new tab
map <Leader>gf <C-w>gf<CR>
"New tab
map <Leader>tn :tabnew<CR>

"Navigate the quickfix list
map <Leader>qn :cnext<CR>
map <Leader>qp :cprev<CR>

"Fugitive shortcuts
map <Leader>gs :Gstatus<CR>
map <Leader>gw :Gwrite<CR>
map <Leader>gc :Gcommit<CR>

"tabularize
map <Leader>a: :Tabularize /:\zs<CR>
map <Leader>a, :Tabularize /,\zs<CR>
map <Leader>a= :Tabularize /=<CR>
map <Leader>af :Tabularize /=><CR>
map <Leader>a{ :Tabularize /{<CR>:Tabularize /}<CR>

"rspec
nmap <Leader>ofs :%s/ it / xit <CR>''?xit<CR>x:w<CR>
nmap <Leader>ons :%s/ xit / it /<CR>'':w<CR>

"vim-rspec  https://github.com/thoughtbot/vim-rspec
nmap <Leader>rf :w<CR>:call RunCurrentSpecFile()<CR>
nmap <Leader>rs :w<CR>:call RunNearestSpec()<CR>
nmap <Leader>rl :w<CR>:call RunLastSpec()<CR>
nmap <Leader>ra :w<CR>:call RunAllSpecs()<CR>

"tslime mappings
nmap <Leader>gx :Tmux gitx<CR>
nmap <Leader>t :Tmux 
" 'Zoom other pane'
nmap <Leader>zo :Tmux tmux resize-pane -U 30<CR>
" 'Zoom back'
nmap <Leader>zb :Tmux tmux resize-pane -D 30<CR>
nmap <Leader>ct :Tmux ctags -R .<CR>

nmap <C-c>r <Plug>SetTmuxVars

" Support different cursor in insert mode.
if &term == "screen-256color"
  let &t_SI = "\<Esc>[3 q"
  let &t_EI = "\<Esc>[0 q"
endif

"Use normal rspec (pushing vim to the background)
"let g:rspec_command = "!rspec {spec}"
"Use tslime
let g:rspec_command = "Tmux rspec {spec}"
"override this with a local .vimrc file, if necessary (e.g. rails projects
"that use spring"


"test::unit
map <Leader>oft :%s/def test/def xtest<CR>''?xtest<CR>x:w<CR>
map <Leader>ont :%s/def xtest/def test/<CR>'':w<CR>

"php unit test
map <Leader>ofp :%s/function test/function xtest<CR>''?xtest<CR>x:w<CR>
map <Leader>onp :%s/function xtest/function test/<CR>'':w<CR>
" turn a comment into a test method
map <Leader>pt <<xxx:s/ /_/gI  function test_A() {}kkk
map <Leader>vd Ovar_dump();<ESC>hi
map <Leader>pl Oerror_log("msg\n", 3, "/tmp/php_errors.log");<ESC>

map <Leader>db Odebugger; 1<CR><ESC>:w<CR>
map <Leader>bp Obinding.pry<CR><ESC>:w<CR>
map <Leader>so Osave_and_open_page<CR><ESC>:w<CR>
map <Leader>br Oborder: 2px solid red;<CR><ESC>:w<CR>
map <Leader>ex Oecho "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n";<CR><ESC>:w<CR>

map <Leader>bo :BufOnly<CR>
map <Leader>bd :bd<CR>

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
autocmd BufReadPost *
\ if line("'\"") > 0 && line("'\"") <= line("$") |
\   exe "normal g`\"" |
\ endif

"Load indent files, to automatically do language-dependent indenting.
filetype plugin indent on

" Load matchit (% to bounce from do to end, etc.)
runtime! macros/matchit.vim

" clean up the sign column for git-gutter
highlight clear SignColumn

" make ctrlp use the git project root as its starting directory
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_match_window_reversed = 0
let g:ctrlp_custom_ignore = '\.(class)'
let g:ctrlp_max_files = 10000
" use git ls-files, if available (faster than find)
" let g:ctrlp_user_command = {
"   \ 'types': { 1: ['.git/', 'cd %s && git ls-files'] },
"   \ 'fallback': 'find %s -type f | head -' . g:ctrlp_max_files
"   \ }

" .vimrc
map <Leader>sv :source ~/.vimrc<CR>''
map <Leader>se :e ~/.vimrc<CR>

" cheat.txt
:command! Cheat sp ~/.dotfiles/vim/cheat.txt

" Ghetto version of snippets/projections
:command! Spec :r ~/.dotfiles/vim/spec.txt

" run ctags
:command! Ctags !ctags -R .

" source .exrc or .vimrc in current folder, on launch
set exrc
" disable shell and filesystem operations from set exrc
set secure

" Additional mappings for surround.vim
" 100 [d]o ... end
let g:surround_100 = "do \r\nend"
" 101 [e]rb
let g:surround_101 = "<%= \r %>"
" 103 [g] for #{...}
let g:surround_103 = "#{\r}"
